<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>D3 Paths</title>
    <script type="text/javascript" src="d3/d3.v3.min.js"></script>
    <script type="text/javascript" src="data.js"></script>
    <script type="text/javascript" src="carData.js"></script>
    <script type="text/javascript" src="paths.js"></script>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div id="content">
      <h1>Path Utilization</h1>
      <hr />
      <div id="carTypeCheckboxes"></div>
      <button id="renderButton">Render</button>
      <button id="resetButton">Reset</button>
    </div>
    <div id="status-bar">
      <p id="status-text">
        Ready...
      </p>
      </div>
    <script type="text/javascript">

      const uniqueCarTypes = Array.from(new Set(car_data.map(d => d["car-type"])));

      // Populate the checkboxes with car types vertically
      const checkboxes = d3.select("#carTypeCheckboxes")
        .selectAll(".checkbox-container")
        .data(uniqueCarTypes)
        .enter().append("div")
        .attr("class", "checkbox-container");

      checkboxes.append("label")
        .text(d => ` ${d}  -- `)
        .append("input")
        .attr("type", "checkbox")
        .attr("class", "carTypeCheckbox")
        .attr("value", d => d);

      // Create a tooltip div
      var tooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);


      // In the interests of readability, we're going to scale the x coordinate to stretch
      // out the graph to fit the wider screen.
      xValues = []
      Object.entries(positions).forEach(e => xValues.push(e[1][0]))
      // positions.values.forEach(v => xValues.append(v[0]));
      max = d3.max(xValues)
      const xScaler = d3.scaleLinear([0, max], [0, 1.7 * max]);

      // set the dimensions and margins of the graph
      var margin = {top: 10, right: 30, bottom: 30, left: 40},
        width = 1800 - margin.left - margin.right,
        height = 1000 - margin.top - margin.bottom;

      // append the svg object to the body of the page
      var svg = d3.select("#content")
      .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform", `translate(${margin.left}, ${margin.top})`);

      var counts = new Map();

      var link = svg.selectAll(".link")
        .data(data.links)
        .enter().append("line")
        .attr("class", "link")
        .style("stroke", "white")
        .style("stroke-width", 0.2)
        .attr("id", d => {return [d.source, d.target].sort().join("-")})
        .attr("x1", d => xScaler(positions[d.source][0]))
        .attr("y1", d => positions[d.source][1])
        .attr("x2", d => xScaler(positions[d.target][0]))
        .attr("y2", d => positions[d.target][1])
        .on("mousemove", function (event, d) {
          var idVal = [d.source, d.target].sort().join("-");
          var count = counts.get("#"+idVal) || 0;
          //console.log(idVal)
          //var cords = d3.pointer(this);
          //console.log(cords)
          tooltip.transition()
            .duration(200)
            .style("opacity", 0.9);
          tooltip.html(`Traversals: ${count}`)
            .style("left", event.pageX + 5 + "px")
            .style("top", event.pageY - 50 + "px");
        })
        .on("mouseout", function (event, d) {
          tooltip.transition()
            .duration(500)
            .style("opacity", 0);
        });         

      // Initialize the nodes
      var node = svg
        .selectAll(".node")
        .data(data.nodes)
        .enter()
        .append("g")
        .attr("class", "node")
        .attr("transform", (d) => `translate(${xScaler(positions[d.id][0])}, ${positions[d.id][1]})`);
        
        node.append("circle")
          .attr("r", 8)
          .style("stroke", "white")
          .style("stroke-width", 2)
          .style("fill", (d) => colorize(d.id));

        node.append("text")
          .attr("dx", 12)
          .attr("dy", ".35em")
          .style("fill", "white")
          .text((d) => d.name );

      // Event listener for "Render" button click
      d3.select("#renderButton").on("click", function() {
        renderGraph(); // Render graph on button click
      });

      d3.select("#resetButton").on("click", function() {
        resetGraph(); // Reset graph on button click
      });
      
      //
      // Iterate over allPaths and increment the width for invidual edges
      //
      function incrementEdge(index, batch) {
        const strokeScaler = d3.scaleLinear([0, allPaths.length / 10], [0.1, 10]);
        for (i = 0 ; i < batch ; i++) {
          if (allPaths.length <= index + i) {
            console.log("Interval iteration complete.");
            return;
          }

          var idVal = `#${allPaths[index+i]}`;
          var line = d3.select(idVal)

          c = counts.get(idVal);
          if (c == undefined) {
            c = 0;            
          }
          c += 1;
          counts.set(idVal, c);

          try {
            // var width = parseFloat(line.style("stroke-width")) + 1;        
            line.style("stroke-width", strokeScaler(c) + "px");
            // console.log(`Incrementing ${line} to ${width}`);
          } catch (e) {
            // console.log(idVal);
          }
        }
      }

      function getSelectedCarTypes() {
        const selectedCarTypes = [];
        d3.selectAll(".carTypeCheckbox:checked").each(function () {
          selectedCarTypes.push(this.value);
        });
        return selectedCarTypes;
      }

      function renderGraph() {
        const selectedCarTypes = getSelectedCarTypes();
        const filteredCarData = car_data.filter(d => selectedCarTypes.includes(d["car-type"]));

        // Extract car IDs from filtered car data
        const filteredCarIds = filteredCarData.map(d => d["car-id"]);

        // Extract paths for the filtered car IDs
        const filteredPaths = {};
        for (const carId of filteredCarIds) {
          if (vehiclePaths.hasOwnProperty(carId)) {
            filteredPaths[carId] = vehiclePaths[carId];
          }
        }

        console.log(filteredPaths);
        console.log(vehiclePaths)

        // List of edge IDs to increment, in no particular order
        allPaths = [];
        Object.entries(filteredPaths).forEach(e => {
          var i = 0;
          x = filteredPaths[e[0]];

          while (i < x.length - 1) {
              allPaths.push([x[i], x[i+1]].sort().join("-"));
              i++;
          } 
        });

        var batch = 100;
        var index = 0;
        var intervalsRemaining = allPaths.length;
        var intervalId = setInterval(function() {
          d3.select("#status-text").html(`${intervalsRemaining} intervals remaining`);
          incrementEdge(index, batch);
          intervalsRemaining -= batch;
          index += batch;

          if (intervalsRemaining <= 0) {        
            clearInterval(intervalId);
            d3.select("#status-text").html("Interval iteration complete");
            console.log(counts)
            // console.log(`Max Count is ${d3.max(counts.values())}`)
          }
        }, 1);
      }

      function resetGraph() {
        //console.log(getSelectedCarTypes())
        location.reload()
      }

    </script>
  </body>
</html>     